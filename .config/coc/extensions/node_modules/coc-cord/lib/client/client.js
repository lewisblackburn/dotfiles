"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const discord_rpc_1 = require("discord-rpc");
const coc_nvim_1 = require("coc.nvim");
const presence_1 = require("../presence/presence");
const logger_1 = require("../logger/logger");
const version_1 = require("../version/version");
class Client {
    constructor(clientID) {
        this.interval = setInterval(() => { }, 1);
        this.connect = (ctx) => __awaiter(this, void 0, void 0, function* () {
            if (!this._client) {
                this._client = new discord_rpc_1.Client({ transport: "ipc" });
            }
            this._client.connect(this._clientID);
            this._client.login({ clientId: this._clientID });
            this._client.on("ready", () => this.ready(ctx));
        });
        this.disconnect = () => __awaiter(this, void 0, void 0, function* () {
            clearInterval(this.interval);
            yield this._client.destroy();
            this._client = undefined;
            logger_1.LOG(logger_1.LogLevel.Info, "disconnected from Discord gateway");
        });
        this.ready = (ctx) => __awaiter(this, void 0, void 0, function* () {
            logger_1.LOG(logger_1.LogLevel.Info, "connected to Discord gateway");
            if (ctx) {
                this.registerCommands(ctx);
            }
            this.trackActivity();
        });
        this.registerCommands = (ctx) => __awaiter(this, void 0, void 0, function* () {
            ctx.subscriptions.push(coc_nvim_1.commands.registerCommand("cord.disconnect", () => {
                logger_1.LOG(logger_1.LogLevel.Info, "trying to disconnect from Discord gateway");
                this.disconnect();
            }));
            ctx.subscriptions.push(coc_nvim_1.commands.registerCommand("cord.reconnect", () => {
                logger_1.LOG(logger_1.LogLevel.Info, "trying to reconnect to Discord gateway");
                this.connect(ctx);
            }));
            ctx.subscriptions.push(coc_nvim_1.commands.registerCommand("cord.version", () => {
                logger_1.LOG(logger_1.LogLevel.Info, `version ${version_1.VERSION}`);
            }));
        });
        this.trackActivity = () => __awaiter(this, void 0, void 0, function* () {
            const startTimeStamp = new Date();
            this.interval = setInterval(() => {
                var _a;
                this._client.setActivity(presence_1.getPresence(startTimeStamp, coc_nvim_1.workspace.root.split("/").pop(), (_a = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.uri)) === null || _a === void 0 ? void 0 : _a.uri.split("/").pop()));
            }, 1000);
        });
        this._clientID = clientID;
        this._client = new discord_rpc_1.Client({ transport: "ipc" });
        clearInterval(this.interval);
    }
}
exports.Client = Client;
