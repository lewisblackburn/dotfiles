"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleCodeActions = exports.handleCompletionResolveRequest = exports.handleRenameRequest = exports.handleCompletionRequest = exports.handleHoverRequest = exports.handleDocumentFormatting = exports.handleDefinitionRequest = exports.handleDiagnosticsRequest = exports.getModelOrEnumBlock = exports.getBlockAtPosition = exports.Block = exports.getWordAtPosition = exports.convertDocumentTextToTrimmedLineArray = exports.getCurrentLine = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const provider_1 = require("./provider");
const format_1 = __importDefault(require("./prisma-fmt/format"));
const completions_1 = require("./completion/completions");
const codeActionProvider_1 = require("./codeActionProvider");
const lint_1 = __importDefault(require("./prisma-fmt/lint"));
const renameUtil_1 = require("./rename/renameUtil");
function getCurrentLine(document, line) {
    return document.getText({
        start: { line: line, character: 0 },
        end: { line: line, character: Number.MAX_SAFE_INTEGER },
    });
}
exports.getCurrentLine = getCurrentLine;
function convertDocumentTextToTrimmedLineArray(document) {
    return Array(document.lineCount)
        .fill(0)
        .map((_, i) => getCurrentLine(document, i).trim());
}
exports.convertDocumentTextToTrimmedLineArray = convertDocumentTextToTrimmedLineArray;
function isFirstInsideBlock(position, currentLine) {
    if (currentLine.trim().length === 0) {
        return true;
    }
    const stringTilPosition = currentLine.slice(0, position.character);
    const matchArray = /\w+/.exec(stringTilPosition);
    if (!matchArray) {
        return true;
    }
    return (matchArray.length === 1 &&
        matchArray.index !== undefined &&
        stringTilPosition.length - matchArray.index - matchArray[0].length === 0);
}
function getWordAtPosition(document, position) {
    const currentLine = getCurrentLine(document, position.line);
    // search for the word's beginning and end
    const beginning = currentLine
        .slice(0, position.character + 1)
        .search(/\S+$/);
    const end = currentLine.slice(position.character).search(/\W/);
    if (end < 0) {
        return '';
    }
    return currentLine.slice(beginning, end + position.character);
}
exports.getWordAtPosition = getWordAtPosition;
class Block {
    constructor(type, start, end, name) {
        this.type = type;
        this.start = start;
        this.end = end;
        this.name = name;
    }
}
exports.Block = Block;
function getBlockAtPosition(line, lines) {
    let blockType = '';
    let blockName = '';
    let blockStart = vscode_languageserver_1.Position.create(0, 0);
    let blockEnd = vscode_languageserver_1.Position.create(0, 0);
    const allowedBlockIdentifiers = ['model', 'enum', 'datasource', 'generator'];
    // get block beginning
    let reachedLine = false;
    for (const [key, item] of lines.reverse().entries()) {
        const actualIndex = lines.length - 1 - key;
        if (actualIndex === line) {
            reachedLine = true;
        }
        if (!reachedLine) {
            continue;
        }
        if (allowedBlockIdentifiers.some((identifier) => item.startsWith(identifier)) &&
            item.includes('{')) {
            const index = item.search(/\s+/);
            blockType = ~index ? item.slice(0, index) : item;
            blockName = item.slice(blockType.length, item.length - 2).trim();
            blockStart = vscode_languageserver_1.Position.create(actualIndex, 0);
            break;
        }
        // not inside a block
        if (item.includes('}')) {
            lines.reverse();
            return;
        }
    }
    reachedLine = false;
    // get block ending
    for (const [key, item] of lines.reverse().entries()) {
        if (key === line) {
            reachedLine = true;
        }
        if (!reachedLine) {
            continue;
        }
        // check if block ends here
        if (item.startsWith('}')) {
            blockEnd = vscode_languageserver_1.Position.create(key, 1);
            return new Block(blockType, blockStart, blockEnd, blockName);
        }
    }
    return;
}
exports.getBlockAtPosition = getBlockAtPosition;
function getModelOrEnumBlock(blockName, lines) {
    // get start position of model type
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(blockName)) ||
            (line.includes('enum') && line.includes(blockName))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = getBlockAtPosition(result, lines);
        if (block && block.name === blockName) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return foundBlocks[0];
}
exports.getModelOrEnumBlock = getModelOrEnumBlock;
function getExperimentalFeaturesRange(document) {
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const experimentalFeatures = 'experimentalFeatures';
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (item.startsWith('generator') && item.includes('{')) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (reachedStartLine && item.startsWith('}')) {
            return;
        }
        if (item.startsWith(experimentalFeatures)) {
            const startIndex = getCurrentLine(document, key).indexOf(experimentalFeatures);
            return {
                start: { line: key, character: startIndex },
                end: { line: key, character: startIndex + experimentalFeatures.length },
            };
        }
    }
}
function handleDiagnosticsRequest(document, binPath, onError) {
    return __awaiter(this, void 0, void 0, function* () {
        const text = document.getText(provider_1.fullDocumentRange(document));
        const res = yield lint_1.default(binPath, text, (errorMessage) => {
            if (onError) {
                onError(errorMessage);
            }
        });
        const diagnostics = [];
        if (res.some((diagnostic) => diagnostic.text === "Field declarations don't require a `:`." ||
            diagnostic.text ===
                'Model declarations have to be indicated with the `model` keyword.')) {
            if (onError) {
                onError("You are currently viewing a Prisma 1 datamodel which is based on the GraphQL syntax. The current Prisma Language Server doesn't support this syntax. Please change the file extension to `.graphql` so the Prisma Language Server does not get triggered anymore.");
            }
        }
        for (const diag of res) {
            const diagnostic = {
                range: {
                    start: document.positionAt(diag.start),
                    end: document.positionAt(diag.end),
                },
                message: diag.text,
                source: '',
            };
            if (diag.is_warning) {
                diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Warning;
            }
            else {
                diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Error;
            }
            diagnostics.push(diagnostic);
        }
        // check for experimentalFeatures inside generator block
        if (document.getText().includes('experimentalFeatures')) {
            const experimentalFeaturesRange = getExperimentalFeaturesRange(document);
            if (experimentalFeaturesRange) {
                diagnostics.push({
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    range: experimentalFeaturesRange,
                    message: "This property has been renamed to 'previewFeatures' to better communicate what they are.",
                    source: '',
                });
            }
        }
        return diagnostics;
    });
}
exports.handleDiagnosticsRequest = handleDiagnosticsRequest;
/**
 * @todo Use official schema.prisma parser. This is a workaround!
 */
function handleDefinitionRequest(document, params) {
    const textDocument = params.textDocument;
    const position = params.position;
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const word = getWordAtPosition(document, position);
    if (word === '') {
        return;
    }
    // get start position of model type
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(word)) ||
            (line.includes('enum') && line.includes(word))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = getBlockAtPosition(result, lines);
        if (block && block.name === word) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    const startPosition = {
        line: foundBlocks[0].start.line,
        character: foundBlocks[0].start.character,
    };
    const endPosition = {
        line: foundBlocks[0].end.line,
        character: foundBlocks[0].end.character,
    };
    return {
        uri: textDocument.uri,
        range: vscode_languageserver_1.Range.create(startPosition, endPosition),
    };
}
exports.handleDefinitionRequest = handleDefinitionRequest;
/**
 * This handler provides the modification to the document to be formatted.
 */
function handleDocumentFormatting(params, document, binPath, onError) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = params.options;
        return format_1.default(binPath, options.tabSize, document.getText(), onError).then((formatted) => [
            vscode_languageserver_1.TextEdit.replace(provider_1.fullDocumentRange(document), formatted),
        ]);
    });
}
exports.handleDocumentFormatting = handleDocumentFormatting;
function handleHoverRequest(document, params) {
    const position = params.position;
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const word = getWordAtPosition(document, position);
    if (word === '') {
        return;
    }
    const foundBlock = getModelOrEnumBlock(word, lines);
    if (!foundBlock) {
        return;
    }
    const commentLine = foundBlock.start.line - 1;
    const docComments = document.getText({
        start: { line: commentLine, character: 0 },
        end: { line: commentLine, character: Number.MAX_SAFE_INTEGER },
    });
    if (docComments.startsWith('///')) {
        return {
            contents: docComments.slice(4).trim(),
        };
    }
    // TODO uncomment once https://github.com/prisma/prisma/issues/2546 is resolved!
    /*if (docComments.startsWith('//')) {
      return {
        contents: docComments.slice(3).trim(),
      }
    } */
    return;
}
exports.handleHoverRequest = handleHoverRequest;
/**
 *
 * This handler provides the initial list of the completion items.
 */
function handleCompletionRequest(params, document, binPath) {
    const context = params.context;
    const position = params.position;
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const currentLineUntrimmed = getCurrentLine(document, position.line);
    const currentLineTillPosition = currentLineUntrimmed
        .slice(0, position.character - 1)
        .trim();
    const wordsBeforePosition = currentLineTillPosition.split(/\s+/);
    const symbolBeforePosition = completions_1.getSymbolBeforePosition(document, position);
    const symbolBeforePositionIsWhiteSpace = symbolBeforePosition.search(/\s/) !== -1;
    const positionIsAfterArray = wordsBeforePosition.length >= 3 &&
        !currentLineTillPosition.includes('[') &&
        symbolBeforePositionIsWhiteSpace;
    const foundBlock = getBlockAtPosition(position.line, lines);
    if (!foundBlock) {
        if (wordsBeforePosition.length > 1 ||
            (wordsBeforePosition.length === 1 && symbolBeforePositionIsWhiteSpace)) {
            return;
        }
        return completions_1.getSuggestionForBlockTypes(lines);
    }
    if (isFirstInsideBlock(position, getCurrentLine(document, position.line))) {
        return completions_1.getSuggestionForFirstInsideBlock(foundBlock.type, lines, position, foundBlock);
    }
    // Completion was triggered by a triggerCharacter
    if ((context === null || context === void 0 ? void 0 : context.triggerKind) === 2) {
        switch (context.triggerCharacter) {
            case '@':
                if (!completions_1.positionIsAfterFieldAndType(position, document, wordsBeforePosition)) {
                    return;
                }
                return completions_1.getSuggestionForFieldAttribute(foundBlock, getCurrentLine(document, position.line), lines, wordsBeforePosition, document, binPath);
            case '"':
                return completions_1.getSuggestionForSupportedFields(foundBlock.type, lines[position.line], currentLineUntrimmed, position, binPath);
            case '.':
                return completions_1.getSuggestionForNativeTypes(foundBlock, wordsBeforePosition, document, binPath, lines);
        }
    }
    switch (foundBlock.type) {
        case 'model':
            // check if inside attribute
            if (completions_1.isInsideAttribute(currentLineUntrimmed, position, '()')) {
                return completions_1.getSuggestionsForInsideAttributes(currentLineUntrimmed, lines, position, foundBlock);
            }
            // check if type
            if (!completions_1.positionIsAfterFieldAndType(position, document, wordsBeforePosition)) {
                return completions_1.getSuggestionsForTypes(foundBlock, lines, position, currentLineUntrimmed);
            }
            return completions_1.getSuggestionForFieldAttribute(foundBlock, lines[position.line], lines, wordsBeforePosition, document, binPath);
        case 'datasource':
        case 'generator':
            if (wordsBeforePosition.length === 1 &&
                symbolBeforePositionIsWhiteSpace) {
                return completions_1.suggestEqualSymbol(foundBlock.type);
            }
            if (currentLineTillPosition.includes('=') &&
                !currentLineTillPosition.includes(']') &&
                !positionIsAfterArray &&
                symbolBeforePosition !== ',') {
                return completions_1.getSuggestionForSupportedFields(foundBlock.type, lines[position.line], currentLineUntrimmed, position, binPath);
            }
            break;
        case 'enum':
            break;
    }
}
exports.handleCompletionRequest = handleCompletionRequest;
function handleRenameRequest(params, document) {
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const position = params.position;
    const currentLine = lines[position.line];
    const currentBlock = getBlockAtPosition(position.line, lines);
    const edits = [];
    if (!currentBlock) {
        return;
    }
    const isModelRename = renameUtil_1.isModelName(params.position, currentBlock, lines, document);
    const isEnumRename = renameUtil_1.isEnumName(params.position, currentBlock, lines, document);
    const isEnumValueRename = renameUtil_1.isEnumValue(currentLine, params.position, currentBlock, document);
    const isValidFieldRename = renameUtil_1.isValidFieldName(currentLine, params.position, currentBlock, document);
    const isRelationFieldRename = isValidFieldRename && renameUtil_1.isRelationField(currentLine, lines);
    if (isModelRename ||
        isEnumRename ||
        isEnumValueRename ||
        isValidFieldRename) {
        const currentName = renameUtil_1.extractCurrentName(currentLine, isModelRename || isEnumRename, isEnumValueRename, isValidFieldRename, document, params.position);
        let lineNumberOfDefinition = position.line;
        let blockOfDefinition = currentBlock;
        let lineOfDefinition = currentLine;
        if (isModelRename || isEnumRename) {
            // get definition of model or enum
            const matchModelOrEnumBlockBeginning = new RegExp(`\\s*(model|enum)\\s+(${currentName})\\s*({)`, 'g');
            lineNumberOfDefinition = lines.findIndex((l) => matchModelOrEnumBlockBeginning.test(l));
            if (lineNumberOfDefinition === -1) {
                return;
            }
            lineOfDefinition = lines[lineNumberOfDefinition];
            const definitionBlockAtPosition = getBlockAtPosition(lineNumberOfDefinition, lines);
            if (!definitionBlockAtPosition) {
                return;
            }
            blockOfDefinition = definitionBlockAtPosition;
        }
        // rename marked string
        edits.push(renameUtil_1.insertBasicRename(params.newName, currentName, document, lineNumberOfDefinition));
        // check if map exists already
        if (!isRelationFieldRename &&
            !renameUtil_1.mapExistsAlready(lineOfDefinition, lines, blockOfDefinition, isModelRename || isEnumRename)) {
            // add map attribute
            edits.push(renameUtil_1.insertMapAttribute(currentName, position, blockOfDefinition, isModelRename || isEnumRename));
        }
        // rename references
        if (isModelRename || isEnumRename) {
            edits.push(...renameUtil_1.renameReferencesForModelName(currentName, params.newName, document, lines));
        }
        else if (isEnumValueRename) {
            edits.push(...renameUtil_1.renameReferencesForEnumValue(currentName, params.newName, document, lines, blockOfDefinition.name));
        }
        else if (isValidFieldRename) {
            edits.push(...renameUtil_1.renameReferencesForFieldValue(currentName, params.newName, document, lines, blockOfDefinition, isRelationFieldRename));
        }
        renameUtil_1.printLogMessage(currentName, params.newName, isEnumRename, isModelRename, isValidFieldRename, isEnumValueRename);
        return {
            changes: {
                [document.uri]: edits,
            },
        };
    }
    return;
}
exports.handleRenameRequest = handleRenameRequest;
/**
 *
 * @param item This handler resolves additional information for the item selected in the completion list.
 */
function handleCompletionResolveRequest(item) {
    return item;
}
exports.handleCompletionResolveRequest = handleCompletionResolveRequest;
function handleCodeActions(params, document) {
    if (!params.context.diagnostics.length) {
        return [];
    }
    return codeActionProvider_1.quickFix(document, params);
}
exports.handleCodeActions = handleCodeActions;
//# sourceMappingURL=MessageHandler.js.map