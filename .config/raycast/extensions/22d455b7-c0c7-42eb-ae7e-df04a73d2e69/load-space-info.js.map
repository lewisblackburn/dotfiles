{
  "version": 3,
  "sources": ["../src/load-space-info.tsx", "../src/helpers/storage.ts"],
  "sourcesContent": ["import { closeMainWindow, popToRoot, showHUD } from \"@raycast/api\";\nimport { useEffect } from \"react\";\nimport { loadAndSaveCapacitiesStore } from \"./helpers/storage\";\n\nexport default function Command() {\n  async function loadInfo() {\n    try {\n      await loadAndSaveCapacitiesStore(true, true);\n      showHUD(\"Info successfully updated.\");\n    } catch (e) {\n      showHUD(e instanceof Error ? e.message : \"Failed to load Capacities store.\");\n    }\n  }\n\n  useEffect(() => {\n    loadInfo().then(() => popToRoot());\n    closeMainWindow();\n  }, []);\n\n  return undefined;\n}\n", "import { LocalStorage, getPreferenceValues } from \"@raycast/api\";\nimport { useState } from \"react\";\n\nconst { bearerToken } = getPreferenceValues<Preferences>();\nexport const API_URL = \"https://api.capacities.io\";\nexport const API_HEADERS = {\n  Accept: \"application/json\",\n  Authorization: `Bearer ${bearerToken}`,\n  \"Content-Type\": \"application/json\",\n};\nconst SPACES_UPDATE_INTERVAL = 1000 * 60 * 10;\nconst SPACE_INFO_UPDATE_INTERVAL = 1000 * 60 * 10;\n\n// API TYPES\ntype GetSpacesInfoResponse = {\n  spaces: {\n    id: string;\n    title: string;\n    icon: unknown;\n  }[];\n};\n\ntype GetSpaceInfoResponse = {\n  structures: {\n    id: string;\n    title: string;\n    pluralName: string;\n    propertyDefinitions: {\n      type: string;\n      id: string;\n      dataType: string;\n      name: string;\n    }[];\n    labelColor: string;\n    collections: {\n      id: string;\n      title: string;\n    }[];\n  }[];\n};\n\ntype CapacitiesStore = {\n  spacesLastUpdated: string | undefined;\n  spaces: { id: string; title: string }[];\n  spacesInfo: {\n    [key: string]:\n      | {\n          lastUpdated: string;\n          structures: GetSpaceInfoResponse[\"structures\"];\n        }\n      | undefined;\n  };\n};\n\nexport function fetchErrorHandler(status: number) {\n  if (status === 429) {\n    return \"Too Many Requests. Please try again later.\";\n  } else if (status === 400) {\n    return \"Invalid request. Please try again.\";\n  } else if (status === 401) {\n    return \"Unauthorized. Please check your API key.\";\n  } else if (status === 500) {\n    return \"Something went wrong.\";\n  } else if (status === 503 || status === 555) {\n    return \"Service Unavailable. Please try again later.\";\n  } else {\n    return \"Request failed. You might be offline, please try again when back online.\";\n  }\n}\n\nasync function getCapacitiesStore(): Promise<CapacitiesStore> {\n  const store = await LocalStorage.getItem<string>(\"capacitiesStore\");\n  if (store) {\n    return JSON.parse(store);\n  } else {\n    return {\n      spacesLastUpdated: undefined,\n      spaces: [],\n      spacesInfo: {},\n    };\n  }\n}\n\nexport async function loadAndSaveCapacitiesStore(forceUpdate: boolean, throwError: boolean): Promise<CapacitiesStore> {\n  let errorMessage: string | undefined = undefined;\n  let store: CapacitiesStore | undefined = undefined;\n  try {\n    store = await getCapacitiesStore();\n    if (\n      forceUpdate ||\n      !store.spacesLastUpdated ||\n      Date.now() - new Date(store.spacesLastUpdated).getTime() > SPACES_UPDATE_INTERVAL\n    ) {\n      try {\n        const response = await fetch(`${API_URL}/spaces`, {\n          headers: API_HEADERS,\n        });\n        if (!response.ok) throw new Error(fetchErrorHandler(response.status));\n        const result = (await response.json()) as GetSpacesInfoResponse;\n        const data = result;\n\n        if (data.spaces) {\n          store.spaces = data.spaces.map((el) => {\n            return {\n              id: el.id,\n              title: el.title,\n            };\n          });\n        }\n        const spaces = data?.spaces || [];\n        for (const space of spaces) {\n          const index = store.spaces.findIndex((s) => s.id === space.id);\n          if (index === -1) {\n            store.spaces.push({\n              id: space.id,\n              title: space.title,\n            });\n          } else {\n            store.spaces[index] = {\n              id: space.id,\n              title: space.title,\n            };\n          }\n        }\n        store.spacesLastUpdated = new Date().toISOString();\n      } catch (e) {\n        errorMessage = `${e}`;\n      }\n    }\n\n    const spaceIdsToUpdate: string[] = [];\n    for (const [spaceId, spaceInfo] of Object.entries(store.spacesInfo)) {\n      if (!store.spaces.find((s) => s.id === spaceId)) {\n        delete store.spacesInfo[spaceId];\n      } else {\n        if (\n          forceUpdate ||\n          !spaceInfo?.lastUpdated ||\n          Date.now() - new Date(spaceInfo?.lastUpdated).getTime() > SPACE_INFO_UPDATE_INTERVAL\n        ) {\n          spaceIdsToUpdate.push(spaceId);\n        }\n      }\n    }\n\n    for (const space of store.spaces) {\n      if (!store.spacesInfo[space.id]) {\n        spaceIdsToUpdate.push(space.id);\n      }\n    }\n\n    for (const spaceId of spaceIdsToUpdate) {\n      try {\n        const response = await fetch(`${API_URL}/space-info?spaceid=${spaceId}`, {\n          headers: API_HEADERS,\n        });\n        if (!response.ok) throw new Error(fetchErrorHandler(response.status));\n        const result = (await response.json()) as GetSpaceInfoResponse;\n        const data = result;\n        store.spacesInfo[spaceId] = {\n          lastUpdated: new Date().toISOString(),\n          structures: data.structures,\n        };\n      } catch (e) {\n        errorMessage = `${e}`;\n      }\n    }\n\n    if (errorMessage && throwError) throw new Error(errorMessage);\n\n    await LocalStorage.setItem(\"capacitiesStore\", JSON.stringify(store));\n    return store;\n  } catch {\n    if (!throwError && store) return store;\n    throw new Error(errorMessage || \"Failed to load Capacities store\");\n  }\n}\n\nexport function useCapacitiesStore(forceUpdate = false) {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [store, setStore] = useState<CapacitiesStore | undefined>(undefined);\n\n  function triggerLoading() {\n    getCapacitiesStore()\n      .then((store) => {\n        setStore(store);\n        if (store.spacesLastUpdated) {\n          setIsLoading(false);\n        }\n      })\n      .catch((e) => {\n        console.error(e?.message);\n        setError(\"Failed to load Capacities store\");\n      });\n\n    loadAndSaveCapacitiesStore(forceUpdate, false)\n      .then((store) => {\n        setStore(store);\n        if (store.spacesLastUpdated) {\n          setIsLoading(false);\n        } else {\n          setError(\"Failed to load Capacities store\");\n        }\n      })\n      .catch((e) => {\n        setError(e?.message || \"Failed to load Capacities store\");\n      });\n  }\n\n  return { store, isLoading, error, triggerLoading };\n}\n"],
  "mappings": "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",
  "names": ["load_space_info_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "import_react", "bearerToken", "API_URL", "API_HEADERS", "SPACES_UPDATE_INTERVAL", "SPACE_INFO_UPDATE_INTERVAL", "fetchErrorHandler", "status", "getCapacitiesStore", "store", "loadAndSaveCapacitiesStore", "forceUpdate", "throwError", "errorMessage", "response", "data", "el", "spaces", "space", "index", "s", "e", "spaceIdsToUpdate", "spaceId", "spaceInfo", "Command", "loadInfo", "loadAndSaveCapacitiesStore", "e"]
}
